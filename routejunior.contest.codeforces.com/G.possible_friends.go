/*
Во многих социальных сетях у пользователей есть возможность указать других пользователей как своих друзей. Помимо этого, часто существует система рекомендации друзей, которая
показывает пользователям людей, с которыми они знакомы косвенно (через кого-то из своих друзей), и предлагает добавить этих людей в список друзей. Вам предстоит разработать
систему рекомендации друзей.

В интересующей нас социальной сети n пользователей, каждому из которых присвоен уникальный id от 1 до n. У каждого пользователя этой сети не более 5 друзей. Очевидно, ни один
пользователь не является другом самому себе, и если пользователь x в списке друзей у пользователя y, то и пользователь y входит в список друзей пользователя x.

Опишем, как должен формироваться список возможных друзей для каждого пользователя. Для пользователя x в список должны входить такие пользователи y, что:

y не является другом x и не совпадает с x;
у пользователя y и у пользователя x есть хотя бы один общий друг;
не существует такого пользователя y′, который удовлетворяет первым двум ограничениям, и у которого строго больше общих друзей с x, чем у y с x.

Иными словами, в список возможных друзей пользователя x входят все такие пользователи, не являющиеся его друзьями, для которых количество общих друзей с x
максимально. Обратите внимание, что список возможных друзей может быть пустым.

Вы должны написать программу, которая по заданной структуре социальной сети формирует списки возможных друзей для всех пользователей сети.

Неполные решения этой задачи (например, недостаточно эффективные) могут быть оценены частичным баллом.
Входные данные

В первой строке заданы два целых числа n и m (2≤n≤50000; 0≤m≤min(n(n−1)2,5n2)) — количество пользователей и количество пар друзей, соответственно.

Далее следуют m строк, в каждой из которых заданы два целых числа xi и yi (1≤xi,yi≤n; xi≠yi) — очередная пара друзей в социальной сети. Каждая пара друзей задается не более
одного раза; у каждого пользователя не более 5 друзей.
Выходные данные

Для каждого пользователя от 1 до n выведите в отдельной строке список его возможных друзей в следующем формате:
если список возможных друзей пуст, выведите одно целое число 0;
иначе выведите id возможных друзей пользователя в возрастающем порядке.
*/
package main

import (
	"bufio"
	"fmt"
	"os"
	"strconv"
)

const (
	MAX_POSSIBLE_FRIENDS = 5
)

func main() {
	in := bufio.NewReader(os.Stdin)
	out := bufio.NewWriter(os.Stdout)
	defer out.Flush()

	var countUsers, countPairs int
	fmt.Fscan(in, &countUsers)
	fmt.Fscanln(in, &countPairs)

	users := make(map[int]map[int]bool)

	for i := 1; i <= countUsers; i++ {
		users[i] = make(map[int]bool, MAX_POSSIBLE_FRIENDS)
	}

	for i := 0; i < countPairs; i++ {
		var f1, f2 int
		fmt.Fscan(in, &f1)
		fmt.Fscan(in, &f2)
		users[f1][f2] = true
		users[f2][f1] = true
	}

	fmt.Fprintln(out)
	for i := 1; i <= countUsers; i++ {
		possibleFriends := make(map[string]int)
		max := 0
		for key1 := range users[i] {
			for key := range users[key1] {
				_, ok := users[i][key]
				if key != i && !ok {
					newKey := strconv.Itoa(key)
					_, ok := possibleFriends[newKey]
					if !ok {
						possibleFriends[newKey] = 1
					} else {
						possibleFriends[newKey]++
					}
					if possibleFriends[newKey] >= max {
						max = possibleFriends[newKey]
					}
				}
			}
		}

		fmt.Fprintln(out, possibleFriends)
		// if max == 0 {
		// 	fmt.Fprintln(out, 0)
		// } else {
		// 	str := ""
		// 	for key := range possibleFriends {
		// 		if max == possibleFriends[key] {
		// 			str += key + " "
		// 		}
		// 	}
		// 	if len(str) >= 2 {
		// 		str = str[0 : len(str)-1]
		// 	}
		// 	fmt.Fprintln(out, str)
		// }
	}

	// fmt.Fprintln(out)
	// for i := 1; i <= countUsers; i++ {
	// 	for key := range users[i] {
	// 		fmt.Fprintln(out, i, key, users[i][key])
	// 	}
	// 	fmt.Fprintln(out)
	// }
}
